driver/rados/rgw_rados.cc:    out_stream_req->set_send_length(astate->size);
driver/rados/rgw_rados.cc:    ret = read_op.iterate(dpp, 0, astate->size - 1, out_stream_req->get_out_cb(), y);
driver/rados/rgw_lc_tier.cc:  return out_req->get_out_cb();
driver/rados/rgw_sync.cc:      req->finish();
driver/rados/rgw_sync.cc:    *pmarker = std::move(req->marker);
driver/rados/rgw_sync.cc:    *entries = std::move(req->entries);
driver/rados/rgw_sync.cc:    *truncated = req->truncated;
driver/rados/rgw_sync.cc:    return req->get_ret_status();
driver/rados/rgw_sync.cc:      req->finish();
driver/rados/rgw_sync.cc:    return req->get_ret_status();
driver/rados/rgw_sync.cc:      req->finish();
driver/rados/rgw_sync.cc:    int r = req->get_ret_status();
driver/rados/rgw_trim_bilog.cc:    return req->get_ret_status();
driver/rados/rgw_trim_bilog.cc:      req->finish();
driver/rados/rgw_cr_rados.cc:  req->get();
driver/rados/rgw_cr_rados.cc:  req->send_request(dpp);
driver/rados/rgw_cr_rados.cc:  req->put();
driver/rados/rgw_cr_rados.cc:    req->finish();
driver/rados/rgw_cr_rados.cc:  set_status() << "request complete; ret=" << req->get_ret_status();
driver/rados/rgw_cr_rados.cc:  return req->get_ret_status();
driver/rados/rgw_cr_rados.cc:    req->finish();
driver/rados/rgw_cr_rados.cc:  set_status() << "request complete; ret=" << req->get_ret_status();
driver/rados/rgw_cr_rados.cc:  return req->get_ret_status();
driver/rados/rgw_cr_rados.cc:    req->finish();
driver/rados/rgw_cr_rados.cc:  return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:      *bucket_info = std::move(req->bucket_info);
driver/rados/rgw_cr_rados.h:      *pattrs = std::move(req->attrs);
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
driver/rados/rgw_cr_rados.h:      req->finish();
driver/rados/rgw_cr_rados.h:    return req->get_ret_status();
rgw_cr_rest.cc:  io_id = req->get_io_id(RGWHTTPClient::HTTPCLIENT_IO_READ |RGWHTTPClient::HTTPCLIENT_IO_CONTROL);
rgw_cr_rest.cc:  req->set_in_cb(this);
rgw_cr_rest.cc:    req->unpause_receive();
rgw_cr_rest.cc:    req->cancel();
rgw_cr_rest.cc:    req->wait(null_yield);
rgw_cr_rest.cc:  int r = req->send(http_manager);
rgw_cr_rest.cc:  req->set_write_drain_cb(&write_drain_notify_cb);
rgw_cr_rest.cc:  int r = req->send(http_manager);
rgw_cr_rest.cc:  req->get_out_headers(attrs);
rgw_cr_rest.cc:    io_read_mask = req->get_io_id(RGWHTTPClient::HTTPCLIENT_IO_READ | RGWHTTPClient::HTTPCLIENT_IO_CONTROL);
rgw_cr_rest.cc:    while (!req->is_done() ||
rgw_cr_rest.cc:        req->get_out_headers(&attrs);
rgw_cr_rest.cc:      if (!req->is_done() || out->length() >= max_size) {
rgw_cr_rest.cc:  return req->is_done();
rgw_cr_rest.cc:    req->cancel();
rgw_cr_rest.cc:    req->wait(null_yield);
rgw_cr_rest.cc:  req->set_send_length(rest_obj.content_len);
rgw_cr_rest.cc:    req->append_header(h.first, h.second);
rgw_cr_rest.cc:    env->manager->io_complete(caller, req->get_io_id(RGWHTTPClient::HTTPCLIENT_IO_WRITE | RGWHTTPClient::HTTPCLIENT_IO_CONTROL));
rgw_cr_rest.cc:    while (!req->is_done()) {
rgw_cr_rest.cc:      if (req->get_pending_send_size() >= PENDING_WRITES_WINDOW) {
rgw_cr_rest.cc:        yield caller->io_block(0, req->get_io_id(RGWHTTPClient::HTTPCLIENT_IO_WRITE | RGWHTTPClient::HTTPCLIENT_IO_CONTROL));
rgw_cr_rest.cc:      yield req->add_send_data(data);
rgw_cr_rest.cc:    return req->get_status();
rgw_cr_rest.cc:    yield req->finish_write();
rgw_cr_rest.cc:    *need_retry = !req->is_done();
rgw_cr_rest.cc:    while (!req->is_done()) {
rgw_cr_rest.cc:      yield caller->io_block(0, req->get_io_id(RGWHTTPClient::HTTPCLIENT_IO_CONTROL));
rgw_cr_rest.cc:      *need_retry = !req->is_done();
rgw_cr_rest.cc:    req->get_out_headers(&headers);
rgw_cr_rest.cc:    return req->get_req_retcode();
rgw_dmclock_sync_scheduler.cc:  { std::lock_guard<std::mutex> lg(req->req_mtx);
rgw_dmclock_sync_scheduler.cc:    req->req_state = ReqState::Ready;
rgw_dmclock_sync_scheduler.cc:    req->req_cv.notify_one();
rgw_dmclock_sync_scheduler.cc:  if (auto ctr = req->counters(c)) {
rgw_dmclock_sync_scheduler.cc:    auto lat = Clock::from_double(get_time()) - Clock::from_double(req->started);
rgw_file.cc:	  f->write_req->timer_id =
rgw_file.cc:    if ((static_cast<off_t>(off) < f->write_req->real_ofs) &&
rgw_file.cc:        ((f->write_req->real_ofs - off) <= len)) {
rgw_file.cc:      overlap = f->write_req->real_ofs - off;
rgw_file.cc:      off = f->write_req->real_ofs;
rgw_file.cc:    f->write_req->put_data(off, bl);
rgw_file.cc:    rc = f->write_req->exec_continue();
rgw_file.cc:	  f->write_req->timer_id, std::chrono::seconds(10));
rgw_file.cc:	rc = f->write_req->get_ret();
rgw_http_client.cc:  ss.req->set_state(ss.bitmask);
rgw_http_client.cc:  return req->wait(y);
rgw_kmip_client_impl.cc:    u->create_req->object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
rgw_kmip_client_impl.cc:    u->create_req->template_attribute = ta;
rgw_kmip_client_impl.cc:      u->get_req->unique_identifier = uvalue;
rgw_kmip_client_impl.cc:      u->locate_req->attributes = a;
rgw_kmip_client_impl.cc:      u->locate_req->attribute_count = ap - a;
rgw_kmip_client_impl.cc:  rs = req->result_status;
rgw_kmip_client_impl.cc:  if (req->operation != rbi->operation) {
rgw_kmip_client_impl.cc:    lderr(cct) << "Failed; response operation mismatch, got " << req->operation << " expected " << rbi->operation << dendl;
rgw_kmip_client_impl.cc:  switch(req->operation)
rgw_kmip_client_impl.cc:      CreateResponsePayload *pld = (CreateResponsePayload *)req->response_payload;
rgw_kmip_client_impl.cc:      LocateResponsePayload *pld = (LocateResponsePayload *)req->response_payload;
rgw_kmip_client_impl.cc:      GetResponsePayload *pld = (GetResponsePayload *)req->response_payload;
rgw_kmip_client_impl.cc:      GetAttributesResponsePayload *pld = (GetAttributesResponsePayload *)req->response_payload;
rgw_kmip_client_impl.cc:      GetAttributeListResponsePayload *pld = (GetAttributeListResponsePayload *)req->response_payload;
rgw_kmip_client_impl.cc:      DestroyResponsePayload *pld = (DestroyResponsePayload *)req->response_payload;
rgw_lib.cc:    RGWOp *op = (req->op) ? req->op : dynamic_cast<RGWOp*>(req);
rgw_lib.cc:    io->init(req->cct);
rgw_lib.cc:    req_state rstate(req->cct, env, &rgw_env, req->id);
rgw_lib.cc:    ret = req->init(rgw_env, env.driver, io, s);
rgw_lib.cc:    ret = req->op_init();
rgw_lib.cc:      ret = req->authorize(op, null_yield);
rgw_lib.cc:      ret = req->read_permissions(op, null_yield);
rgw_lib.cc:    RGWOp *op = (req->op) ? req->op : dynamic_cast<RGWOp*>(req);
rgw_lib.cc:    req_state* s = req->get_state();
rgw_lib.cc:    RGWLibIO& io_ctx = req->get_io();
rgw_lib.cc:    int ret = req->init(rgw_env, env.driver, &io_ctx, s);
rgw_lib.cc:    ret = req->op_init();
rgw_lib.cc:    ret = req->authorize(op, null_yield);
rgw_lib.cc:    ret = req->read_permissions(op, null_yield);
rgw_lib.cc:    req->exec_start();
rgw_lib.cc:    RGWOp *op = (req->op) ? req->op : dynamic_cast<RGWOp*>(req);
rgw_lib.cc:    int ret = req->exec_finish();
rgw_loadgen.cc:  left_to_read = req->content_length;
rgw_loadgen.cc:  snprintf(buf, sizeof(buf), "%lld", (long long)req->content_length);
rgw_loadgen.cc:  env.set("CONTENT_TYPE", req->content_type.c_str());
rgw_loadgen.cc:  env.set("HTTP_DATE", req->date_str.c_str());
rgw_loadgen.cc:  for (map<string, string>::iterator iter = req->headers.begin(); iter != req->headers.end(); ++iter) {
rgw_loadgen.cc:  env.set("REQUEST_METHOD", req->request_method.c_str());
rgw_loadgen.cc:  env.set("REQUEST_URI", req->uri.c_str());
rgw_loadgen.cc:  env.set("QUERY_STRING", req->query_string.c_str());
rgw_loadgen.cc:  env.set("SCRIPT_URI", req->uri.c_str());
rgw_loadgen.cc:  snprintf(port_buf, sizeof(port_buf), "%d", req->port);
rgw_loadgen_process.cc:  renv.content_length = req->content_length;
rgw_loadgen_process.cc:  renv.request_method = req->method;
rgw_loadgen_process.cc:  renv.uri = req->resource;
rgw_loadgen_process.cc:    if (req->fail_flag) {
rgw_loadgen_process.cc:      req->fail_flag++;
rgw_process.cc:    req->op = op;
rgw_process.cc:  req_state rstate(g_ceph_context, penv, &rgw_env, req->id);
rgw_process.cc:  s->req_id = driver->zone_unique_id(req->id);
rgw_process.cc:  s->trans_id = driver->zone_unique_trans_id(req->id);
rgw_process.cc:  req->op = op;
rgw_rest_client.cc:    req->add_send_data(bl);
rgw_rest_client.cc:  req->add_send_data(new_bl);
rgw_rest_conn.cc:  int ret = req->complete_request(y, &etag, mtime);
rgw_rest_conn.cc:    set_url_unconnectable(req->get_url_orig());
rgw_rest_conn.cc:  int ret = req->complete_request(y, etag, mtime, psize, pattrs, pheaders);
rgw_rest_conn.cc:    set_url_unconnectable(req->get_url_orig());
services/svc_mdlog.cc:      req->finish();
services/svc_mdlog.cc:    int ret = req->get_ret_status();
services/svc_mdlog.cc:	*objv_tracker = req->objv_tracker;
services/svc_mdlog.cc:	auto iter = req->bl.cbegin();
services/svc_mdlog.cc:      req->finish();
services/svc_mdlog.cc:      *objv_tracker = req->objv_tracker;
services/svc_mdlog.cc:    return req->get_ret_status();
