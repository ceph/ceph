#!/usr/bin/python

import argparse
import copy
import fcntl
import json
import os
import rados
import readline
import select
import socket
import stat
import string
import struct
import subprocess
import sys
import types
import uuid

verbose = False

"""
Something wrong with arguments
"""
class ArgumentError(Exception):
    pass

"""
Wrong number of a repeated argument
"""
class ArgumentNumber(ArgumentError):
    pass

"""
Argument value has wrong format 
"""
class ArgumentFormat(ArgumentError):
    pass

"""
Argument value is otherwise invalid (doesn't match choices, for instance)
"""
class ArgumentValid(ArgumentError):
    pass

"""
Special for mismatched prefix; less severe, don't report by default
"""
class ArgumentPrefix(ArgumentError):
    pass

"""
some semantic issue with the JSON
"""
class JsonFormat(Exception):
    pass

"""
Base class for all Ceph argument types

Instantiating an object sets any validation parameters 
(allowable strings, numeric ranges, etc.).  The 'valid'
method validates a string against that initialized instance,
throwing ArgumentError if there's a problem.
"""
class CephArgtype(object):
    def __init__(self, **kwargs):
        """
        set any per-instance validation parameters here 
        from kwargs (fixed string sets, integer ranges, etc)
        """
        pass

    def valid(self, s, partial=False):
        """
        Run validation against given string s (generally one word);
        partial means to accept partial string matches (begins-with).
        If cool, set self.val to the value that should be returned
        (a copy of the input string, or a numeric or boolean interpretation
        thereof, for example), and return True
        if not, throw ArgumentError(msg-as-to-why)
        """
        pass

    def __repr__(self):
        """
        return string representation of description of type.  Note,
        this is not a representation of the actual value.  Subclasses
        probably also override __str__() to give a more user-friendly
        'name/type' description for use in command format help messages.
        """
        a = ''
        if hasattr(self, 'typeargs'):
            a = self.typeargs
        return '{}(\'{}\')'.format(self.__class__.__name__, a)

    def __str__(self):
        """
        where __repr__ (ideally) returns a string that could be used to
        reproduce the object, __str__ returns one you'd like to see in
        print messages.  Use __str__ to format the argtype descriptor
        as it would be useful in a command usage message.
        """
        return '<{}>'.format(self.__class__.__name__)

"""
range-limited integers, [+|-][0-9]+ or 0x[0-9a-f]+
range: list of 1 or 2 ints, [min] or [min,max]
"""
class CephInt(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(long, self.range)

    def valid(self, s, partial=False):
        try:
            val = long(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent an int".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])

        return '<int{}>'.format(r)


"""
range-limited float type
range: list of 1 or 2 floats, [min] or [min, max]
"""
class CephFloat(CephArgtype):
    def __init__(self, range=''):
        if range == '':
            self.range = list()
        else:
            self.range = list(range.split('|'))
            self.range = map(float, self.range)

    def valid(self, s, partial=False):
        try:
            val = float(s)
        except ValueError:
            raise ArgumentValid("{} doesn't represent a float".format(s))
        if len(self.range) == 2:
            if val < self.range[0] or val > self.range[1]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        elif len(self.range) == 1:
            if val < self.range[0]:
                raise ArgumentValid("{} not in range {}".format(val, self.range))
        self.val = val
        return True

    def __str__(self):
        r = ''
        if len(self.range) == 1:
            r = '[{}-]'.format(self.range[0])
        if len(self.range) == 2:
            r = '[{}-{}]'.format(self.range[0], self.range[1])
        return '<float{}>'.format(r)

"""
String.  Not much use for this; maybe we might use illegal chars
for something?
"""
class CephString(CephArgtype):
    def __init__(self, badchars=''):
        self.badchars = badchars

    def valid(self, s, partial=False):
        for c in self.badchars:
            if c in s:
                raise ArgumentFormat("bad char {} in {}".format(c, s))
        self.val = s
        return True

    def __str__(self):
        b = ''
        if len(self.badchars):
            b = '(without chars in {})'.format(self.badchars)
        return '<string{}>'.format(b)

"""
Admin socket path; check that it's readable and S_ISSOCK
"""
class CephSocketpath(CephArgtype):
    def valid(self, s, partial=False):
        mode = os.stat(s).st_mode
        if not stat.S_ISSOCK(mode):
            raise ArgumentValid('socket path {} is not a socket'.format(s))
        self.val = s
        return True
    def __str__(self):
        return '<admin-socket-path>'

"""
IP address (v4 or v6) with optional port
"""
class CephIPAddr(CephArgtype):
    def valid(self, s, partial=False):
        # parse off port, use socket to validate addr
        type = 6
        if s.startswith('['):
            type = 6
        elif s.find('.') != -1:
            type = 4
        if type == 4:
            port = s.find(':')
            if (port != -1):
                a = s[:port]
                p = s[port+1:]
                if int(p) > 65535:
                    raise ArgumentValid('{}: invalid IPv4 port'.format(p))
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET, a)
            except:
                raise ArgumentValid('{}: invalid IPv4 address'.format(a))
        else:
            # v6
            if s.startswith('['):
                end = s.find(']')
                if end == -1:
                    raise ArgumentFormat('{} missing terminating ]'.format(s))
                if s[end+1] == ':':
                    try:
                        p = int(s[end+2])
                    except:
                        raise ArgumentValid('{}: bad port number'.format(s))
                a = s[1:end]
            else:
                a = s
                p = None
            try:
                socket.inet_pton(socket.AF_INET6, a)
            except:
                raise ArgumentValid('{} not valid IPv6 address'.format(s))
        if p is not None and long(p) > 65535:
            raise ArgumentValid("{} not a valid port number".format(p))
        self.val = s
        return True

    def __str__(self):
        return '<IPaddr[:port]>' 

class CephEntityAddr(CephIPAddr):
    def valid(self, s, partial=False):
        ip, nonce = s.split('/')
        if not super(self.__class__, self).valid(ip):
            raise ArgumentValid('CephEntityAddr {}: ip address invalid'.format(s))
        self.val = s
        return True

    def __str__(self):
        return '<EntityAddr>'

"""
Pool name; checked for presence in cluster
"""
class CephPoolname(CephArgtype):
    def valid(self, s, partial=False):
        # XXX 
        # if cluster.pool.exists(s):
        #    raise ArgumentValid("pool {} does not exist".format(s))
        self.val = s
        return True

    def __str__(self):
        return '<poolname>'

"""
Object name.  Maybe should be combined with Pool name as they're always
present in pairs, and then could be checked for presence
"""
class CephObjectname(CephArgtype):
    def valid(self, s, partial=False):
        self.val = s
        return True

    def __str__(self):
        return '<objectname>'

"""
pgid, in form N.xxx (N = pool number, xxx = hex pgnum)
"""
class CephPgid(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('.') == -1:
            raise ArgumentFormat('pgid has no .')
        poolid, pgnum = s.split('.')
        if poolid < 0:
            raise ArgumentFormat('pool {} < 0'.format(poolid))
        try:
            pgnum = int(pgnum, 16)
        except:
            raise ArgumentFormat('pgnum {} not hex integer'.format(pgnum))
        self.val = s
        return True

    def __str__(self):
        return '<pgid>'

"""
Name, or type.id, where type is osd|mon|client|mds, and id is a base10 int.
Also accept '*'
"""
class CephName(CephArgtype):
    def valid(self, s, partial=False):
        if s == '*':
            self.val = s
            self.nametype = None
            self.nameid = None
            return True
        if s.find('.') == -1:
            raise ArgumentFormat('no .')
        t, i = s.split('.')
        if not t in ('osd', 'mon', 'client', 'mds'):
            raise ArgumentValid('unknown type ' + self.t)
        if t == 'osd':
            try:
                i = int(i)
            except:
                raise ArgumentFormat('osd id ' + i + ' not integer')
            # could check for valid id?
        self.val = s
        self.nametype = t
        self.nameid = i
        return True

    def __str__(self):
        return '<name (type.id)>'

"""
Set of string literals; init with valid choices
"""

class CephChoices(CephArgtype):
    def __init__(self, strings='', **kwargs):
        self.strings=strings.split('|')

    def valid(self, s, partial=False):
        if not partial:
            if not s in self.strings:
                # show as __str__ does: {s1|s2..}
                raise ArgumentValid("{} not in {}".format(s, self))
            self.val = s
            return True

        # partial
        for t in self.strings:
            if t.startswith(s):
                self.val = s
                return True
        raise ArgumentValid("{} not in {}".  format(s, self))

    def __str__(self):
        if len(self.strings) == 1:
            return '{}'.format(self.strings[0])
        else:
            return '{{{}}}'.format('|'.join(self.strings))

"""
Openable file
"""
class CephFilepath(CephArgtype):
    def valid(self, s, partial=False):
        try:
            f = open(s, 'a+')
        except Exception as e:
            raise ArgumentValid('can\'t open {}: {}'.format(s, e))
        f.close()
        self.val = s
        return True

    def __str__(self):
        return '<outfilename>'

"""
'Fragment' ??? XXX
"""
class CephFragment(CephArgtype):
    def valid(self, s, partial=False):
        if s.find('/') == -1:
            raise ArgumentFormat('{}: no /'.format(s))
        val, bits = s.split('/')
        # XXX is this right?
        if not val.startswith('0x'):
            raise ArgumentFormat("{} not a hex integer".format(val))
        try:
            long(val)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(val))
        try:
            long(bits)
        except:
            raise ArgumentFormat('can\'t convert {} to integer'.format(bits))
        self.val = s
        return True

    def __str__(self):
        return "<CephFS fragment ID (0xvvv/bbb)>"


""" 
CephUUID: pretty self-explanatory
"""
class CephUUID(CephArgtype):
    def valid(self, s, partial=False):
        try:
            uuid.UUID(s)
        except Exception as e:
            raise ArgumentFormat('invalid UUID {}: {}'.format(s, e))
        self.val = s
        return True

    def __str__(self):
        return '<uuid>'

"""
CephPrefix: magic type for "all the first n fixed strings"
"""
class CephPrefix(CephArgtype):
    def __init__(self, prefix=''):
        self.prefix = prefix

    def valid(self, s, partial=False):
        if partial:
            if self.prefix.startswith(s):
                self.val = s
                return True
        else:
            if (s == self.prefix):
                self.val = s
                return True
        raise ArgumentPrefix("no match for {}".format(s))

    def __str__(self):
        return self.prefix

############################################################################

# argdesc(typename, [type-specific kwargs], name='name', n=numallowed, req=False, helptext=helptext, **kwargs)
# validation rules:
# typename: type(**kwargs) will be constructed
# later, type.valid(w) will be called with a word in that position
# name is used for parse errors and for constructing JSON output
# n is a numeric literal or 'n|N', meaning "at least one, but maybe more"
# req=False means the argument need not be present in the list
# helptext is the associated help for the command
# anything else are arguments to pass to the type constructor.
# self.instance is an instance of type t constructed with typeargs.
# valid() will later be called with input to validate against it,
# and will store the validated value in self.instance.val for extraction.

class argdesc(object):
    def __init__(self, t, name=None, n=1, req=True, **kwargs):
        if isinstance(t, types.StringTypes):
            self.t = CephPrefix
            self.typeargs = {'prefix':t}
            self.req = True
        else:
            self.t = t
            self.typeargs = kwargs
            self.req = bool(req == True or req == 'True')

        self.name = name
        self.N = (n in ['n', 'N'])
        if self.N:
            self.n = 1
        else:
            self.n = int(n)
        self.instance = self.t(**self.typeargs)

    def __repr__(self):
        r = 'argdesc(' + str(self.t) + ', '
        internals = ['N', 'typeargs', 'instance', 't']
        for (k,v) in self.__dict__.iteritems():
            if k.startswith('__') or k in internals:
                pass
            else:
                # undo mods above
                if k == 'n' and self.N:
                    v = 'N'
                r += '{}={}, '.format(k,v)
        for (k,v) in self.typeargs.iteritems():
                r += '{}={}, '.format(k,v)
        return r[:-2] + ')'

    def __str__(self):
        if ((self.t == CephChoices and len(self.instance.strings) == 1)
            or (self.t == CephPrefix)):
            s = '{}'.format(str(self.instance))
        else:
            s = '{}({})'.format(self.name, str(self.instance))
            if self.N:
                s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

    # like above, but omit parameter names
    def helpstr(self):
        s = '{}'.format(str(self.instance))
        if self.N:
            s += '[' + str(self.instance) + '...]'
        if not self.req:
            s = '{' + s + '}'
        return s

def concise_sig(sig):
    first = True
    s = ''
    for d in sig:
        if first:
            first = False
        else:
            s += ' '
        s += d.helpstr()
    return s

"""
parse_json_funcsigs(s)

A function signature is mostly an array of argdesc; it's represented
in JSON as 
{ 
  "cmd1": {"sig":[ "type": type, "name": name, "n": num, "req":true|false <other param>], "help:{"help":helptext}
   .
   .
   .
  ]

A set of sigs is in an dict mapped by a unique number:
{
  "cmd1": {
     "sig": ["type.. ], "help":{"text":helptext}
  }
  "cmd2"{
     "sig": [.. ], "help":{"text":helptext}
  }
}

Parse the string s and return an dict of dicts, keyed by opcode;
each dict contains 'sig' with the array of descriptors, and 'help'
with the helptext.
"""


def parse_json_funcsig(s):
    try:
        overall = json.loads(s)
    except Exception as e:
        print >> sys.stderr, "Couldn't parse JSON {}: {}".format(s, e)
        raise e
    sigdict = {}
    for cmdtag, cmd in overall.iteritems():
        helptext = cmd.get('help', 'no help available')
        try:
            sig = cmd['sig']
        except KeyError:
            s = "JSON descriptor {} has no 'sig'".format(cmdtag)
            raise JsonFormat(s)

        newsig = []
        argnum = 0
        for desc in sig:
            argnum += 1
            if isinstance(desc, types.StringTypes):
                t = CephPrefix
                desc = {'type':t, 'name':'prefix', 'prefix':desc}
            else:
                # not a simple string, must be dict
                if not 'type' in desc:
                    s = 'JSON descriptor {} has no type'.format(sig)
                    raise JsonFormat(s)
                # look up type string in our globals() dict; if it's an
                # object of type types.TypeType, it must be a
                # locally-defined class. otherwise, we haven't a clue.
                if desc['type'] in globals():
                    t = globals()[desc['type']]
                    if type(t) != types.TypeType:
                        s = 'unknown type {}'.format(desc['type'])
                        raise JsonFormat(s)
                else:
                    s = 'unknown type {}'.format(desc['type'])
                    raise JsonFormat(s)

            kwargs = dict()
            for key, val in desc.items():
                if key not in ['type', 'name', 'n', 'req']:
                    kwargs[key] = val
            newsig.append(argdesc(t,
                                  name=desc.get('name', None),
                                  n=desc.get('n', 1),
                                  req=desc.get('req', True),
                                  **kwargs))
        sigdict[cmdtag] = {'sig':newsig, 'helptext':helptext}
    return sigdict

"""
validate_one(word, desc, partial=False)

Return true if word matches desc (or partially, if partial == True).
Raise exception if not.
"""
def validate_one(word, desc, partial=False):
    # validate word against the constructed instance of the type
    # in desc.  May raise exception.  If it returns false (and doesn't
    # raise an exception), desc.instance.val will
    # contain the validated value (in the appropriate type).
    if desc.instance.valid(word, partial):
        desc.numseen += 1
        if desc.N:
            desc.n = desc.numseen + 1
        return True
    return False

"""
matchnum(s, signature, partial=False)

Returns number of arguments matched in s against signature.
Can be used to determine most-likely command for full or partial
matches (partial applies to string matches).
"""

def matchnum(args, signature, partial=False):
    words = args[:]
    mysig = copy.deepcopy(signature)
    matchcnt = 0
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            if not words:
                return matchcnt;
            word = words.pop(0)
            # may raise exception
            try:
                validate_one(word, desc, partial)
            except:
                if not desc.req:
                    words.insert(0, word)
                    break
                else:
                    return matchcnt
        if desc.req:
            matchcnt += 1
    return matchcnt

"""
validate(s, signature)

Assumes s represents a possible command input following format of
signature.  Runs a validation; no exception means it's OK.  Return
a dict containing all arguments named by their descriptor name
(with duplicate args per name accumulated into a space-separated
value).
"""

def validate(args, signature):
    words = args[:]
    mysig = copy.deepcopy(signature)
    d = dict()
    for desc in mysig:
        setattr(desc, 'numseen', 0)
        while desc.numseen < desc.n:
            if words:
                word = words.pop(0)
            else:
                if desc.req:
                    if desc.N and desc.numseen < 1:
                        raise ArgumentNumber('saw {} of {}, expected at least 1'.format(desc.numseen, desc))
                    elif not desc.N and desc.numseen < desc.n:
                        raise ArgumentNumber('saw {} of {}, expected {}'.format(desc.numseen, desc, desc.n))
                break
            try:
                validate_one(word, desc)
            except Exception as e:
                if not desc.req:
                    words.insert(0, word)
                    break
                else:
                    raise e

            if desc.N:
                # value should be a list
                if desc.name in d:
                    d[desc.name] += [desc.instance.val]
                else:
                    d[desc.name] = [desc.instance.val]
            elif (desc.t == CephPrefix) and (desc.name in d):
                # value should be a space-joined concatenation
                d[desc.name] += ' ' + desc.instance.val
            else:
                # if first CephPrefix or any other type, just set it
                d[desc.name] = desc.instance.val
    return d

def parse_cmdargs(args=None, usage='', epilog='', add_help=True):
    # alias: let the line-wrapping be sane
    AP = argparse.ArgumentParser
    # formatter_class: don't linewrap epilog (our custom-formatted help)
    parser = AP(description='Frontend for ceph CLI', usage=usage,
                epilog=epilog, add_help=add_help,
                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-c', dest='cephconf',
                        help='ceph configuration file')
    parser.add_argument('-i', '--in-file', dest='input_file',
                        help='input file')
    parser.add_argument('--id', dest='client_id',
                        help='client id for authentication')
    parser.add_argument('--name', '-n', dest='client_name',
                        help='client name for authentication')
    parser.add_argument('-o', '--out-file', dest='output_file',
                        help='output file')
    parser.add_argument('-k', '--keyring', dest='keyring_file',
                        help='keyring file')
    parser.add_argument('--admin-daemon', dest='admin_socket',
                        help='submit admin-socket commands (\"help\" for help')
    parser.add_argument('-s', '--status', action='store_true', help='show cluster status')
    parser.add_argument('-w', '--watch', action='store_true', help='watch live cluster changes')
    parser.add_argument('--watch-debug', action='store_true',
                        help='watch debug events')
    parser.add_argument('--watch-info', action='store_true',
                        help='watch info events')
    parser.add_argument('--watch-sec', action='store_true',
                        help='watch sec events')
    parser.add_argument('--watch-warn', action='store_true',
                        help='watch warn events')
    parser.add_argument('--watch-error', action='store_true',
                        help='watch error events')
    parser.add_argument('-v', '--verbose', action="store_true")
    parser.add_argument('--concise')
    parser.add_argument('-f', '--format', choices=['json', 'json-pretty', 'xml', 'xml-pretty', 'plain'], dest='output_format')
    # for pg dump_stuck
    parser.add_argument('--threshold', type=int, help='number of seconds for a pg to be considered stuck for pg dump_stuck')
    # returns a Namespace with the parsed args, and a list of all extras
    return parser.parse_known_args(args)

def get_process_output(args):
    if verbose:
        print >> sys.stderr, "get_process_output({})".format(args)

    p = subprocess.Popen(args, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    outdata, errdata = p.communicate()
    if (len(errdata)):
        print "error: ", errdata
    return outdata

def do_command(command, d, endless=False):

    def make_nonblocking(filelist):
        for f in filelist:
            flags = fcntl.fcntl(f, fcntl.F_GETFL)
            fcntl.fcntl(f, fcntl.F_SETFL, flags | os.O_NONBLOCK)

    full_command = command + [ json.dumps(d) ]
    if verbose:
        print >> sys.stderr, "invoking ", full_command
    p = subprocess.Popen(full_command, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    if endless:
        try:
            make_nonblocking([p.stdout, p.stderr])
            fdlist = [p.stdout.fileno(), p.stderr.fileno()]
            while not p.poll():
                (r, _, e) = select.select(fdlist, [], fdlist, 1)
                if (p.stdout.fileno() in r):
                    sys.stdout.write(p.stdout.read())
                if (p.stderr.fileno() in r):
                    sys.stderr.write(p.stderr.read())
                if e:
                    print >> sys.stderr, "error on process stdout/stderr"
        except KeyboardInterrupt:
            p.terminate()
            pass

    else:
        outdata, errdata = p.communicate()
        if len(errdata):
            sys.stderr.write(errdata)
        sys.stdout.write(outdata)
    return p.returncode

"""
sort descriptors by prefixes, defined as the concatenation of all simple
strings in the descriptor; this works out to just the leading strings.
"""
def descsort(sh1, sh2):
    return cmp(concise_sig(sh1['sig']), concise_sig(sh2['sig']))


"""
generator to transform s into a sequence of strings width or shorter,
for wrapping text to a specific column width.
Attempt to break on anything but dontsplit characters.
indent is amount to indent 2nd-through-nth lines.

so "long string long string long string" width=11 indent=1 becomes
'long string', ' long string', ' long string' so that it can be printed
as 
long string
 long string
 long string

Consumes s.
"""
dontsplit = string.letters + '{[<>]}'

def wrap(s, width, indent):
    result = ''
    leader = ''
    while len(s):

        if (len(s) <= width):
            # no splitting; just possibly indent
            result = leader + s
            s = ''
            yield result

        else:
            splitpos = width
            while (splitpos > 0) and (s[splitpos-1] in dontsplit):
                splitpos -= 1

            if splitpos == 0:
                splitpos = width

            if result:
                # prior result means we're mid-iteration, indent
                result = leader
            else:
                # first time, set leader and width for next
                leader = ' ' * indent
                width -= 1      # for subsequent space additions

            # remove any leading spaces in this chunk of s
            result += s[:splitpos].lstrip()
            s = s[splitpos:]

            yield result

    raise StopIteration

def format_help(cmddict):
    fullusage = ''
    for cmd in sorted(cmddict.itervalues(), cmp=descsort):

        siglines = [l for l in wrap(concise_sig(cmd['sig']), 40, 1)]
        helplines = [l for l in wrap(cmd['helptext'], 39, 1)]

        # make lists the same length
        maxlen = max(len(siglines), len(helplines))
        siglines.extend([''] * (maxlen - len(siglines)))
        helplines.extend([''] * (maxlen - len(helplines)))

        # so we can zip them for output
        for (s, h) in zip(siglines, helplines):
            fullusage += '{:40s} {}\n'.format(s, h)

    return fullusage

def validate_command(parsed_args, sigdict, args):
    """
    turn args into a valid dictionary ready to be sent off as JSON,
    validated against sigdict.
    parsed_args is the namespace back from argparse
    """
    found = []
    valid_dict = {}
    if args:
        # look for best match, accumulate possibles in bestsigs
        # (so we can maybe give a more-useful error message)
        best_match_cnt = 0
        bestsigs = []
        for cmdtag, cmd in sigdict.iteritems():
            sig = cmd['sig']
            matched = matchnum(args, sig, partial=True)
            if (matched > best_match_cnt):
                if verbose:
                    print >> sys.stderr, \
                        "better match: {} > {}:{}:{} ".format(matched,
                                      cmdtag, best_match_cnt, concise_sig(sig))
                best_match_cnt = matched
                bestsigs = [{cmdtag:cmd}]
            elif matched == best_match_cnt:
                if verbose:
                    print >> sys.stderr, \
                        "equal match: {} > {}:{}:{} ".format(matched,
                                      cmdtag, best_match_cnt, concise_sig(sig))
                bestsigs.append({cmdtag:cmd})

        if verbose:
            print >> sys.stderr, "bestsigs: ", bestsigs

        # for everything in bestsigs, look for a true match
        for cmdsig in bestsigs:
            for (cmdtag, cmd) in cmdsig.iteritems():
                sig = cmd['sig']
                helptext = cmd['helptext']
                try:
                    valid_dict = validate(args, sig)
                    found = sig
                    break
                except ArgumentPrefix:
                    # this means a CephPrefix type didn't match; since
                    # this is common, just eat it
                    pass
                except ArgumentError as e:
                    # prefixes matched, but some other arg didn't;
                    # this is interesting information
                    print >> sys.stderr, '{}: invalid command'.\
                        format(' '.join(args))
                    print >> sys.stderr, '{}'.format(e)
                    print >> sys.stderr, "did you mean {}?\n\t{}".\
                        format(concise_sig(sig), helptext)
                    pass

        if not found:
            print >> sys.stderr, 'no valid command found'
            print >> sys.stderr, 'close matches:'
            for cmdsig in bestsigs:
                for (cmdtag, cmd) in cmdsig.iteritems():
                    print >> sys.stderr, concise_sig(cmd['sig'])
            return None

        if parsed_args.output_format:
            valid_dict['format'] = parsed_args.output_format

        if parsed_args.threshold:
            valid_dict['threshold'] = parsed_args.threshold

        return valid_dict

def json_command(prefix=None, argdict=None, inbuf=''):
    global cluster
    cmddict = {}
    if prefix:
        cmddict.update({'prefix':prefix})
    if argdict:
        cmddict.update(argdict)
    try:
        if cmddict['prefix'] == 'pg' and cmddict.has_key('pgid'):
            pgid = cmddict.pop('pgid')
            ret, outbl, outs = \
                cluster.pg_command(pgid, json.dumps(cmddict), inbuf)
        elif cmddict['prefix'] == 'tell' and cmddict.has_key('target'):
            targ = CephName()
            target = cmddict.pop('target')
            targ.valid(target)
            if targ.nametype == 'osd':
                osdid = targ.nameid
                ret, outbl, outs = \
                    cluster.osd_command(osdid, json.dumps(cmddict), inbuf)
            else:
                raise RuntimeError('Unhandled tell: {}'.format(targ.val))
        else:
            ret, outbl, outs = cluster.mon_command(json.dumps(cmddict), inbuf)
    except Exception as e:
        raise RuntimeError('"{}": exception {}'.format(prefix, e))

    return ret, outbl, outs

def admin_socket(asok_path, cmd):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(asok_path)
        sock.sendall(' '.join(cmd) + '\0')

        len_str = sock.recv(4)
        l, = struct.unpack(">I", len_str)

        got = 0
        while got < l:
            bit = sock.recv(l - got)
            print bit
            got += len(bit)

    except Exception as e:
        raise RuntimeError('exception: {}'.format(e))

    return 0


def ceph_conf(field, name):
    p = subprocess.Popen(
        args=[
            'ceph-conf',
            field,
            '-n',
            name,
            ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    outdata, errdata = p.communicate()
    if (len(errdata)):
        raise RuntimeError('unable to get conf option %s for %s: %s' % (field, name, errdata))
    return outdata.rstrip()


###
# main
###

def main():
    global cluster

    # we have to parse twice, because we have to collect early
    # options to be able to run the "get_command_descriptions" command.
    parsed_args, childargs = parse_cmdargs(add_help=False)

    global verbose
    verbose = parsed_args.verbose

    extraconf = {}

    # pass on --id, --name, -k, -c
    name = None
    if parsed_args.client_id:
        name = 'client.' + parsed_args.client_id
    if parsed_args.client_name:
        name = parsed_args.client_name

    if parsed_args.keyring_file:
        extraconf.update({'keyring':parsed_args.keyring_file})

    # default '' means default conf search
    conffile = ''
    if parsed_args.cephconf:
        conffile = parsed_args.cephconf

    """
    XXX need to handle watch here
    # This is ugly, but Namespace() isn't quite rich enough.
    # Handle any --watch or -w command by marking endless,
    # passing on.
    for k,v in parsed_args._get_kwargs():
        if k.startswith('watch') and v:
            arg = '--' + k.replace('_', '-')
            command.append(arg)
            endless = True;
            got_command = True
    """

    # For now, --admin-daemon is handled as usual
    if parsed_args.admin_socket:
        return admin_socket(parsed_args.admin_socket, childargs)

    if len(childargs) > 0 and childargs[0] == "daemon":
        if len(childargs) > 2:
            if childargs[1].find('/') >= 0:
                return admin_socket(childargs[1], childargs[2:])
            else:
                # try resolve daemon name
                path = ceph_conf('admin_socket', childargs[1])
                return admin_socket(path, childargs[2:])
        else:
            print >> sys.stderr, 'Daemon requires at least 2 arguments'
            return 1

    if len(extraconf) == 0:
        extraconf = None

    cluster = rados.Rados(rados_id=name, conf=extraconf, conffile=conffile)
    cluster.connect()

    # fetch JSON sigs from command
    # each line contains one command signature (a placeholder name
    # of the form 'cmdNNN' followed by an array of argument descriptors)
    # as part of the validated argument JSON object

    ret, outbl, outs = json_command('get_command_descriptions')
    if ret:
        print >> sys.stderr, 'Problem getting command descriptions from ceph-mon, error {}'.format(ret)
        return ret

    sigdict = parse_json_funcsig(outbl)

    parsed_args, cmdargs = parse_cmdargs(epilog='\nAvailable commands: \n\n'
                                           + format_help(sigdict))

    if verbose:
        for cmdtag in sorted(sigdict.keys()):
            cmd = sigdict[cmdtag]
            sig = cmd['sig']
            print '{}: {}'.format(cmdtag, concise_sig(sig))

    got_command = False
    endless = False

    inbuf = ''
    if parsed_args.input_file:
        try:
            with open(parsed_args.input_file, 'r') as f:
                inbuf = f.read()
        except Exception as e:
            print >> sys.stderr, 'Can\'t open input file {}: {}'.format(parsed_args.input_file, e)
            return 1

    if parsed_args.output_file:
        try:
            outf = open(parsed_args.output_file, 'w')
        except:
            print >> sys.stderr, 'Can\'t open output file {}: {}'.format(parsed_args.output_file, e)
            return 1

    # -s behaves like a command (ceph status). 
    if parsed_args.status:
        valid_dict = {'prefix':'status'}
        got_command = True

    if not got_command:
        if cmdargs:
            # Validate input args against list of sigs
            valid_dict = validate_command(parsed_args, sigdict, cmdargs)
            if valid_dict:
                got_command = True
            else:
                return 1
        else:
            while True:
                interactive_input = raw_input('ceph> ')
                if interactive_input in ['q', 'quit', 'Q']:
                    break
                cmdargs = parse_cmdargs(interactive_input.split())[1]
                valid_dict = validate_command(parsed_args, sigdict, cmdargs)
                if valid_dict:
                    ret, outbuf, outs = json_command(argdict=valid_dict)
                    if ret:
                        sys.stderr.write('Error {}: {}'.format(ret, outs))
                        return 1
                else:
                    print "invalid command"

    ret, outbuf, outs = json_command(argdict=valid_dict, inbuf=inbuf)

    if ret:
        sys.stderr.write('Error {}: {}'.format(ret, outs))
        return ret

    if (parsed_args.output_file):
        outf.write(outbuf)
        outf.close()
    else:
        sys.stdout.write(outbuf)

    # XXX make sure outs always has only error or status
    sys.stderr.write(outs)
    return 0

if __name__ == '__main__':
    sys.exit(main())
