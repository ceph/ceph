#!/usr/bin/python3

import os
import re
import string
import sys
import logging
import syslog
from typing import Optional


logger = logging.getLogger('rbdmap-generator')

RBDMAP_PATH = os.environ.get('RBDMAPFILE', '/etc/ceph/rbdmap')

RBDMAP_TEMPLATE = '''# Automatically generated by rbdmap-generator

[Unit]
SourcePath={rbdmap_path}
Description=Map RBD device %I
Documentation=man:rbdmap-generator(8)
DefaultDependencies=no
IgnoreOnIsolate=true
Conflicts=umount.target
Wants=blockdev@dev-rbd-%i.target network-online.target
Before=blockdev@dev-rbd-%i.target
After=remote-fs-pre.target rbdmap-pre.target systemd-udevd-kernel.socket network.target network-online.target
{unit_extra}

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/rbd device map %I{rdb_map_args}
ExecStartPost=-/etc/ceph/rbd.d/%I map /dev/rbd/%I
ExecStop=-/etc/ceph/rbd.d/%I unmap /dev/rbd/%I
ExecStop=/usr/bin/rbd device unmap %I{rbd_unmap_args}
'''

VALID_CHARS = string.ascii_letters + string.digits + ':_.'

def systemd_escape(p: str, path=True):
    res = ''
    for c in p:
        if c == '/':
            res += '-'
        elif c in VALID_CHARS:
            res += c
        else:
            res += ''.join(R'\x{:02x}'.format(b) for b in c.encode())
    if res[0] == '.':
        res = R'\x2e' + res[1:]
    return res

def systemd_escape_path(p: str):
    if (p == '/'):
        return '-'
    p = p.strip('/')
    p = re.sub(r'/{2,}', '/', p)
    return systemd_escape(p)

def normalize_rbd_spec(spec: str):
    if spec.startswith('/') or spec.endswith('/'):
        raise ValueError(
            'rbd image or snapshot specification {} cannot starts or ends with /'
            .format(spec))
    if '/' not in spec:
        spec = 'rbd/' + spec
    return spec

def split_options(options: str):
    in_quote = False
    working = ''
    for c in options:
        if c == "'":
            in_quote = not in_quote
        elif c == ',' and not in_quote:
            yield working
            working = ''
        else:
            working += c
    yield working

SYSTEMD_KEY_PREFIX = 'x-systemd.'
RBDMAP_TARGET = 'rbdmap.target'
DEVICE_TYPE_KEY = 'device-type'
RBD_MAP_ARGS = {
    # global args
    'conf', 'cluster', 'id', 'name', 'mon_host', 'keyfile', 'keyring',
    # map args
    DEVICE_TYPE_KEY, 'read-only', 'exclusive', 'quiesce', 'quiesce-hook',
}

def parse_opts(opts: Optional[str]):
    bool_options = {
        'fail': True,
        'auto': True,
    }
    systemd_unit_options = {
        'required-by': [],
        'wanted-by': [],
        'requires': [],
        'requires-mounts-for': [],
        'before': [],
        'after': [],
    }
    rbd_map_args = []
    rbd_map_arg_options = []
    device_type = None
    if opts:
        for a in split_options(opts):
            if a in bool_options:
                bool_options[a] = True
                continue
            if a.startswith('no'):
                k = a[2:]
                if k in bool_options:
                    bool_options[k] = False
                    continue

            kv = a.split('=', maxsplit=1)
            if a.startswith('x-'):
                if a.startswith(SYSTEMD_KEY_PREFIX):
                    if len(kv) < 2:
                        logger.warning('option %s should contains a value, ignoring', a)
                        continue
                    k, v = kv
                    k = k[len(SYSTEMD_KEY_PREFIX):]
                    if k not in systemd_unit_options:
                        logger.warning('unknown systemd option %s, ignoring', a)
                        continue
                    systemd_unit_options[k].append(v)
                    continue
            if kv[0] == 'options':
                if len(kv) < 2:
                    logger.warning('option %s should contains a value, ignoring', a)
                    continue
                rbd_map_arg_options += kv[1].split(',')
                continue
            if kv[0] in RBD_MAP_ARGS:
                rbd_map_args.append(a)
                if kv[0] == DEVICE_TYPE_KEY:
                    if len(kv) < 2:
                        raise ValueError('{} should contains a value'.format(DEVICE_TYPE_KEY))
                    device_type = kv[1]
                continue

            rbd_map_arg_options.append(a)

    if rbd_map_arg_options:
        rbd_map_args.append('options=' + ','.join(rbd_map_arg_options))

    if bool_options['auto']:
        if bool_options['fail']:
            systemd_unit_options['required-by'].append(RBDMAP_TARGET)
        else:
            systemd_unit_options['wanted-by'].append(RBDMAP_TARGET)
    if bool_options['fail']:
        systemd_unit_options['before'].append(RBDMAP_TARGET)

    return systemd_unit_options, device_type, rbd_map_args

def generate_one(line: str, dir_fd: int):
    def opener(path, flags):
        return os.open(path, flags, dir_fd=dir_fd, mode=0o644)

    cells = line.split(maxsplit=1)
    rbd_spec = cells[0]
    map_opts = cells[1] if len(cells) >= 2 else None
    rbd_spec = normalize_rbd_spec(rbd_spec)
    rbd_dev_path = '/dev/rbd/' + rbd_spec
    map_unit_name = 'rbdmap@{}.service'.format(systemd_escape(rbd_spec))
    device_unit_name = systemd_escape_path(rbd_dev_path) + '.device'
    systemd_unit_options, device_type, rbd_map_args = parse_opts(map_opts)

    unit_extra = []
    unit_options_map = [
        ['requires', 'Requires'],
        ['requires-mounts-for', 'RequiresMountsFor'],
        ['before', 'Before'],
        ['after', 'After'],
    ]
    for k, option in unit_options_map:
        if systemd_unit_options[k]:
            unit_extra.append(option + '=' + ' '.join(systemd_unit_options[k]))

    rbd_unmap_args = ''
    if device_type is not None:
        rbd_unmap_args += ' --device-type=' + device_type

    template_args = {
        'rbdmap_path': RBDMAP_PATH,
        'rdb_map_args': ''.join(' --' + a for a in rbd_map_args),
        'unit_extra': '\n'.join(unit_extra),
        'rbd_unmap_args': rbd_unmap_args,
    }
    with open(map_unit_name, 'w', opener=opener) as f:
        f.write(RBDMAP_TEMPLATE.format_map(template_args))

    # install unit
    link_src = os.path.join('..', map_unit_name)
    installs = [
        ['requires', systemd_unit_options['required-by'] + [device_unit_name]],
        ['wants', systemd_unit_options['wanted-by']],
    ]
    for op, units in installs:
        for u in units:
            install_dir = u + '.' + op
            try:
                os.mkdir(install_dir, mode=0o755, dir_fd=dir_fd)
            except FileExistsError:
                pass
            os.symlink(
                src=link_src,
                dst=os.path.join(install_dir, map_unit_name),
                dir_fd=dir_fd,
            )

def generate(normal_dir: str, early_dir: str, late_dir: str):
    failed = False
    with open(RBDMAP_PATH, 'r') as f:
        dir_fd = os.open(normal_dir, os.O_RDONLY)
        for i, line in enumerate(f):
            if re.match(r'^\s*(#|$)', line):
                continue
            try:
                generate_one(line.strip(), dir_fd)
            except:
                logger.error('failed to generate unit for line %d', i, exc_info=True)
                failed = True
        os.close(dir_fd)
    return 1 if failed else 0

class KmsgLogHandler(logging.StreamHandler):
    def __init__(self):
        super().__init__(stream=open('/dev/kmsg', 'w'))
        self.setFormatter(logging.Formatter('%(message)s'))
        self._level_to_syslog = {
            logging.CRITICAL: syslog.LOG_CRIT,
            logging.ERROR: syslog.LOG_ERR,
            logging.WARNING: syslog.LOG_WARNING,
            logging.INFO: syslog.LOG_INFO,
            logging.DEBUG: syslog.LOG_DEBUG,
        }
        self.name = os.path.basename(sys.argv[0])

    def format(self, record: logging.LogRecord) -> str:
        msg = super().format(record)
        piro = self._level_to_syslog.get(record.levelno, syslog.LOG_WARNING) | (syslog.LOG_USER << 3)
        return '<{}>{}[{}]: {}'.format(piro, self.name, record.process, msg)

def except_hook(type, value, traceback):
    logger.error('error while generating units', exc_info=(type, value, traceback))

def main():
    if os.geteuid() == 0:
        # as in systemd.generator(7)
        logging.basicConfig(handlers=[KmsgLogHandler()], level=logging.INFO)
    else:
        logging.basicConfig(level=logging.INFO)

    sys.excepthook = except_hook

    if len(sys.argv) == 1:
        ret = generate('/tmp', '/tmp', '/tmp')
    elif len(sys.argv) == 4:
        ret = generate(sys.argv[1], sys.argv[2], sys.argv[3])
    else:
        print('Wrong number of args', file=sys.stderr)
        return 1
    return ret

if __name__ == '__main__':
    exit(main())
