#!/usr/bin/python3

import logging
import os
import re
import string
import sys
import syslog
from typing import Dict, List, NamedTuple, Optional

logger = logging.getLogger('rbdmap-generator')

RBDMAP_PATH = os.environ.get('RBDMAPFILE', '/etc/ceph/rbdmap')
RBDTAB_PATH = os.environ.get('RBDTABFILE', '/etc/ceph/rbdtab')

RBDMAP_TEMPLATE = '''# Automatically generated by rbdmap-generator

[Unit]
SourcePath={source_path}
Description=Map RBD device %I
Documentation=man:rbdmap-generator(8)
DefaultDependencies=no
IgnoreOnIsolate=true
Conflicts=umount.target
Wants=blockdev@dev-rbd-%i.target network-online.target
Before=blockdev@dev-rbd-%i.target
After=remote-fs-pre.target rbdmap-pre.target systemd-udevd-kernel.socket network.target network-online.target
{unit_extra}

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/rbd device map %I{rbd_map_args}
ExecStop=/usr/bin/rbd device unmap %I{rbd_unmap_args}
{service_extra}'''

RBDMAP_LAGENCY_HOOKS = \
'''ExecStartPost=-/etc/ceph/rbd.d/%I map /dev/rbd/%I
ExecStop=-/etc/ceph/rbd.d/%I unmap /dev/rbd/%I
'''

VALID_CHARS = string.ascii_letters + string.digits + ':_.'

def systemd_escape(p: str, path=True):
    res = ''
    for c in p:
        if c == '/':
            res += '-'
        elif c in VALID_CHARS:
            res += c
        else:
            res += ''.join(R'\x{:02x}'.format(b) for b in c.encode())
    if res[0] == '.':
        res = R'\x2e' + res[1:]
    return res

def systemd_escape_path(p: str):
    if (p == '/'):
        return '-'
    p = p.strip('/')
    p = re.sub(r'/{2,}', '/', p)
    return systemd_escape(p)

def normalize_rbd_spec(spec: str):
    if spec.startswith('/') or spec.endswith('/'):
        raise ValueError(
            'rbd image or snapshot specification {} cannot starts or ends with /'
            .format(spec))
    if '/' not in spec:
        spec = 'rbd/' + spec
    return spec

def split_rbdmap_options(options: str):
    in_quote = False
    working = ''
    for c in options:
        if c == "'":
            in_quote = not in_quote
        elif c == ',' and not in_quote:
            yield working
            working = ''
        else:
            working += c
    yield working

class RbdMapSpec(NamedTuple):
    rbd_spec: str
    systemd_unit_options: Dict[str, List[str]]
    device_type: Optional[str]
    map_generic_args: List[str]
    map_options: Optional[str]
    unmap_options: Optional[str]
    service_extra: Optional[str] = None

def empty_systemd_unit_options():
    return {
        'required-by': [],
        'wanted-by': [],
        'requires': [],
        'requires-mounts-for': [],
        'before': [],
        'after': [],
    }

def parse_rbdmap_line(line: str):
    cells = line.split(maxsplit=1)
    rbd_spec = cells[0]
    opts = cells[1] if len(cells) >= 2 else None
    map_generic_args = []
    device_type = None
    map_options = None
    if opts:
        for a in split_rbdmap_options(opts):
            kv = a.split('=', maxsplit=1)
            if kv[0] == 'device-type':
                if len(kv) < 2:
                    raise ValueError('device-type should have a value')
                device_type = kv[1]
            elif kv[0] == 'options':
                if len(kv) >= 2:
                    map_options = kv[1]
            else:
                map_generic_args.append(a)

    return RbdMapSpec(
        rbd_spec, empty_systemd_unit_options(), device_type, map_generic_args, map_options,
        unmap_options=None,
        service_extra=RBDMAP_LAGENCY_HOOKS,
    )

SYSTEMD_KEY_PREFIX = 'x-systemd.'
RBDMAP_TARGET = 'rbdmap.target'
NONE_PLACEHOLDERS = ['none', '-']

def parse_rbdtab_line(line: str):
    bool_options = {
        'fail': True,
        'auto': True,
    }
    systemd_unit_options = empty_systemd_unit_options()

    device_type, rbd_spec, *cells = line.split()
    map_generic_args = []

    def next_cell():
        if len(cells) == 0:
            return None
        c = cells.pop(0)
        return None if c in NONE_PLACEHOLDERS else c

    c = next_cell()
    if c is not None:
        for a in c.split(','):
            if a in bool_options:
                bool_options[a] = True
                continue
            if a.startswith('no'):
                k = a[2:]
                if k in bool_options:
                    bool_options[k] = False
                    continue

            kv = a.split('=', maxsplit=1)
            if a.startswith('x-'):
                if a.startswith(SYSTEMD_KEY_PREFIX):
                    if len(kv) < 2:
                        logger.warning('option %s should contains a value, ignoring', a)
                        continue
                    k, v = kv
                    k = k[len(SYSTEMD_KEY_PREFIX):]
                    if k not in systemd_unit_options:
                        logger.warning('unknown systemd option %s, ignoring', a)
                        continue
                    systemd_unit_options[k].append(v)
                    continue

            map_generic_args.append(a)

    if bool_options['auto']:
        if bool_options['fail']:
            systemd_unit_options['required-by'].append(RBDMAP_TARGET)
        else:
            systemd_unit_options['wanted-by'].append(RBDMAP_TARGET)
    if bool_options['fail']:
        systemd_unit_options['before'].append(RBDMAP_TARGET)

    return RbdMapSpec(
        rbd_spec, systemd_unit_options, device_type, map_generic_args,
        map_options=next_cell(),
        unmap_options=next_cell(),
    )

def generate_one(spec: RbdMapSpec, dir_fd: int, source: str):
    def opener(path, flags):
        return os.open(path, flags, dir_fd=dir_fd, mode=0o644)

    rbd_spec = normalize_rbd_spec(spec.rbd_spec)
    rbd_dev_path = '/dev/rbd/' + rbd_spec
    map_unit_name = 'rbdmap@{}.service'.format(systemd_escape(rbd_spec))
    device_unit_name = systemd_escape_path(rbd_dev_path) + '.device'

    unit_extra = []
    unit_options_map = [
        ['requires', 'Requires'],
        ['requires-mounts-for', 'RequiresMountsFor'],
        ['before', 'Before'],
        ['after', 'After'],
    ]
    for k, option in unit_options_map:
        if spec.systemd_unit_options[k]:
            unit_extra.append(option + '=' + ' '.join(spec.systemd_unit_options[k]))

    rbd_map_args = ''.join(' --' + a for a in spec.map_generic_args)
    rbd_unmap_args = ''
    if spec.device_type is not None:
        a = ' --device-type=' + spec.device_type
        rbd_map_args += a
        rbd_unmap_args += a

    if spec.map_options:
        rbd_map_args += ' --options=' + spec.map_options
    if spec.unmap_options:
        rbd_unmap_args += ' --options=' + spec.unmap_options

    template_args = {
        'source_path': source,
        'rbd_map_args': rbd_map_args,
        'rbd_unmap_args': rbd_unmap_args,
        'unit_extra': '\n'.join(unit_extra),
        'service_extra': spec.service_extra or '',
    }
    with open(map_unit_name, 'w', opener=opener) as f:
        f.write(RBDMAP_TEMPLATE.format_map(template_args))

    # install unit
    link_src = os.path.join('..', map_unit_name)
    installs = [
        ['requires', spec.systemd_unit_options['required-by'] + [device_unit_name]],
        ['wants', spec.systemd_unit_options['wanted-by']],
    ]
    for op, units in installs:
        for u in units:
            install_dir = u + '.' + op
            try:
                os.mkdir(install_dir, mode=0o755, dir_fd=dir_fd)
            except FileExistsError:
                pass
            os.symlink(
                src=link_src,
                dst=os.path.join(install_dir, map_unit_name),
                dir_fd=dir_fd,
            )

def generate(normal_dir: str, early_dir: str, late_dir: str):
    failed = False

    if os.path.exists(RBDTAB_PATH):
        config_file = RBDTAB_PATH
        parser = parse_rbdtab_line
    else:
        config_file = RBDMAP_PATH
        parser = parse_rbdmap_line

    with open(config_file, 'r') as f:
        dir_fd = os.open(normal_dir, os.O_RDONLY)
        for i, line in enumerate(f):
            if re.match(r'^\s*(#|$)', line):
                continue
            try:
                generate_one(parser(line.strip()), dir_fd, config_file)
            except:
                logger.error('failed to generate unit for line %d', i, exc_info=True)
                failed = True
        os.close(dir_fd)
    return 1 if failed else 0

class KmsgLogHandler(logging.StreamHandler):
    def __init__(self):
        super().__init__(stream=open('/dev/kmsg', 'w'))
        self.setFormatter(logging.Formatter('%(message)s'))
        self._level_to_syslog = {
            logging.CRITICAL: syslog.LOG_CRIT,
            logging.ERROR: syslog.LOG_ERR,
            logging.WARNING: syslog.LOG_WARNING,
            logging.INFO: syslog.LOG_INFO,
            logging.DEBUG: syslog.LOG_DEBUG,
        }
        self.name = os.path.basename(sys.argv[0])

    def format(self, record: logging.LogRecord) -> str:
        msg = super().format(record)
        piro = self._level_to_syslog.get(record.levelno, syslog.LOG_WARNING) | (syslog.LOG_USER << 3)
        return '<{}>{}[{}]: {}'.format(piro, self.name, record.process, msg)

def except_hook(type, value, traceback):
    logger.error('error while generating units', exc_info=(type, value, traceback))

def main():
    if os.geteuid() == 0:
        # as in systemd.generator(7)
        logging.basicConfig(handlers=[KmsgLogHandler()], level=logging.INFO)
    else:
        logging.basicConfig(level=logging.INFO)

    sys.excepthook = except_hook

    if len(sys.argv) == 1:
        ret = generate('/tmp', '/tmp', '/tmp')
    elif len(sys.argv) == 4:
        ret = generate(sys.argv[1], sys.argv[2], sys.argv[3])
    else:
        print('Wrong number of args', file=sys.stderr)
        return 1
    return ret

if __name__ == '__main__':
    exit(main())
