# systemd_unit.py - creating/managing systemd unit files

import contextlib
import os
import json
import pathlib

from typing import Any, Dict, IO, List, Optional, Union

from . import templating
from .call_wrappers import call_throws
from .container_engines import Docker, Podman
from .context import CephadmContext
from .daemon_identity import DaemonIdentity, DaemonSubIdentity
from .exceptions import SystemdDropInException
from .file_utils import write_new
from .logging import write_cluster_logrotate_config


_DROP_IN_FILENAME = '99-cephadm.conf'


class SystemdDropIn:
    """Class for specifying the contents of a systemd drop-in file"""

    def __init__(self) -> None:
        self.contents: Dict[str, Dict[str, List[str]]] = {}

    @classmethod
    def from_dict(
        self, data: Dict[str, Dict[str, List[str]]]
    ) -> 'SystemdDropIn':
        dropin = SystemdDropIn()
        dropin.contents = data
        return dropin

    def add_section(self, section: str) -> None:
        if section not in self.contents.keys():
            self.contents[section] = {}

    def add_setting(self, section: str, setting: str, value: str) -> None:
        if section not in self.contents.keys():
            raise SystemdDropInException(
                f'section {section} not present in drop-in'
            )

        if setting not in self.contents[section]:
            self.contents[section][setting] = []
        self.contents[section][setting].append(value)

    def rm_section(self, section: str) -> None:
        if section in self.contents.keys():
            del self.contents[section]

    def rm_setting(
        self, section: str, setting: str, value: Optional[str] = None
    ) -> None:
        if section not in self.contents.keys():
            raise SystemdDropInException(
                f'section {section} not present in drop-in'
            )
        # our drop-ins could have multiple values for the same setting in the same
        # section e.g.
        #
        # [Unit]
        # Wants = unit1
        # Wants = unit2
        #
        # so we need to be able to either remove a specific value if it was
        # passed or remove all values if nothing is specified
        if setting in self.contents[section] and not value:
            del self.contents[section][setting]
        elif setting in self.contents[section] and value:
            try:
                self.contents[section][setting].remove(value)
            except ValueError:
                raise SystemdDropInException(
                    f'Section {section} setting {setting} does not have value {value}'
                )
            if len(self.contents[section][setting]) == 0:
                del self.contents[section][setting]

    def to_str(self) -> str:
        drop_in_text = '# generated by cephadm\n'
        for section, settings in self.contents.items():
            drop_in_text += f'[{section}]\n'
            for setting, values in settings.items():
                drop_in_text += '\n'.join(
                    [f'{setting}={value}' for value in values]
                )
            drop_in_text += '\n'
        return drop_in_text

    def write_drop_in_to_filehandler(self, fh: IO) -> None:
        if not self:
            # nothing to write out
            return
        drop_in_contents = self.to_str()
        fh.write(drop_in_contents)

    def __bool__(self) -> bool:
        if not self.contents or not any(
            self.contents[key] for key in self.contents.keys()
        ):
            # no contents
            return False
        return True

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SystemdDropIn):
            return False
        if len(self.contents.keys()) != len(other.contents.keys()):
            # different amount of sections
            return False
        for section in self.contents.keys():
            if section not in other.contents.keys():
                # different sections
                return False
            if len(self.contents[section].keys()) != len(
                other.contents[section].keys()
            ):
                # different amount of settings in section
                return False
            for setting, value in self.contents[section].items():
                if setting not in other.contents[section]:
                    # setting in this section not present in other
                    return False
                if set(value) != set(other.contents[section][setting]):
                    # different values for this specific setting
                    return False
        return True

    def __repr__(self) -> str:
        return f'SystemdDropIn:\n{json.dumps(self.contents, indent=4)}'


class PathInfo:
    """Utility class to map basic service identities, to the paths used by
    their corresponding systemd unit files.
    """

    def __init__(
        self,
        unit_dir: Union[str, pathlib.Path],
        identity: DaemonIdentity,
        sidecar_ids: Optional[List[DaemonSubIdentity]] = None,
    ) -> None:
        self.identity = identity
        self.sidecar_ids = sidecar_ids or []

        unit_dir = pathlib.Path(unit_dir)
        self.default_unit_file = unit_dir / f'ceph-{identity.fsid}@.service'
        self.init_ctr_unit_file = unit_dir / identity.init_service_name
        self.sidecar_unit_files = {
            si: unit_dir / si.sidecar_service_name for si in self.sidecar_ids
        }
        dname = f'{identity.service_name}.d'
        self.drop_in_file = unit_dir / dname / _DROP_IN_FILENAME


def _build_extra_containers_drop_in(
    dropin: SystemdDropIn,
    ctx: CephadmContext,
    identity: DaemonIdentity,
    enable_init_containers: bool,
    sidecar_ids: List[DaemonSubIdentity],
) -> SystemdDropIn:
    # This was formerly done my a template that looked like
    #
    # # generated by cephadm
    # [Unit]
    # {%- if enable_init_containers %}
    # Wants={{ identity.init_service_name }}
    # {%- endif %}
    # {%- for sidecar in sidecar_ids %}
    # Wants={{ sidecar.sidecar_service_name }}
    # {%- endfor %}

    if enable_init_containers or sidecar_ids:
        dropin.add_section('Unit')
    if enable_init_containers:
        dropin.add_setting(
            section='Unit', setting='Wants', value=identity.init_service_name
        )
    for sidecar in sidecar_ids:
        dropin.add_setting(
            section='Unit',
            setting='Wants',
            value=sidecar.sidecar_service_name,
        )
    return dropin


def _update_drop_in_files(
    ctx: CephadmContext,
    pinfo: PathInfo,
    ident: DaemonIdentity,
    enable_init_containers: bool = False,
) -> None:
    """Build and write out drop-in files for this service"""
    # this should one day be able to handle custom drop-ins
    # from a spec file. For now just special case handling
    # and init/sidecar container drop-ins
    dropin = SystemdDropIn()
    # create a drop-in to create a relationship between the primary
    # service and the init- and sidecar-based services.
    sidecar_ids = [si for si in pinfo.sidecar_unit_files.keys()]
    if enable_init_containers or sidecar_ids:
        dropin = _build_extra_containers_drop_in(
            dropin, ctx, ident, enable_init_containers, sidecar_ids
        )
    if ident.daemon_type == 'node-exporter':
        # node-exporter returns code 143 when sent SIGTERM
        dropin.add_section('Service')
        dropin.add_setting(
            section='Service',
            setting='SuccessExitStatus',
            value='143',
        )
    if dropin:
        pinfo.drop_in_file.parent.mkdir(parents=True, exist_ok=True)
        with write_new(pinfo.drop_in_file, perms=None) as f:
            dropin.write_drop_in_to_filehandler(f)


def _write_init_containers_unit_file(
    dest: IO, ctx: CephadmContext, identity: DaemonIdentity
) -> None:
    has_docker_engine = isinstance(ctx.container_engine, Docker)
    has_podman_engine = isinstance(ctx.container_engine, Podman)
    templating.render_to_file(
        dest,
        ctx,
        templating.Templates.init_ctr_service,
        identity=identity,
        has_docker_engine=has_docker_engine,
        has_podman_engine=has_podman_engine,
        has_podman_split_version=(
            has_podman_engine and ctx.container_engine.supports_split_cgroups
        ),
    )


def _write_sidecar_unit_file(
    dest: IO,
    ctx: CephadmContext,
    primary: DaemonIdentity,
    sidecar: DaemonSubIdentity,
) -> None:
    has_docker_engine = isinstance(ctx.container_engine, Docker)
    has_podman_engine = isinstance(ctx.container_engine, Podman)
    templating.render_to_file(
        dest,
        ctx,
        templating.Templates.sidecar_service,
        primary=primary,
        sidecar=sidecar,
        sidecar_script=sidecar.sidecar_script(ctx.data_dir),
        has_docker_engine=has_docker_engine,
        has_podman_engine=has_podman_engine,
        has_podman_split_version=(
            has_podman_engine and ctx.container_engine.supports_split_cgroups
        ),
    )


def _install_extended_systemd_services(
    ctx: CephadmContext,
    pinfo: PathInfo,
    identity: DaemonIdentity,
    enable_init_containers: bool = False,
) -> None:
    """Install the systemd unit files needed for more complex services
    that have init containers and/or sidecars. Does not include drop-ins
    """
    with contextlib.ExitStack() as estack:
        # install the unit file to handle running init containers
        if enable_init_containers:
            icfh = estack.enter_context(
                write_new(pinfo.init_ctr_unit_file, perms=None)
            )
            _write_init_containers_unit_file(icfh, ctx, identity)

        # install the unit files to handle running sidecars
        sids = []
        for si, sup in pinfo.sidecar_unit_files.items():
            sufh = estack.enter_context(write_new(sup, perms=None))
            _write_sidecar_unit_file(sufh, ctx, identity, si)
            sids.append(si)


def _get_unit_file(ctx: CephadmContext, fsid: str) -> str:
    has_docker_engine = isinstance(ctx.container_engine, Docker)
    has_podman_engine = isinstance(ctx.container_engine, Podman)
    has_podman_split_version = (
        has_podman_engine and ctx.container_engine.supports_split_cgroups
    )
    return templating.render(
        ctx,
        templating.Templates.ceph_service,
        fsid=fsid,
        has_docker_engine=has_docker_engine,
        has_podman_engine=has_podman_engine,
        has_podman_split_version=has_podman_split_version,
    )


def _install_base_units(ctx: CephadmContext, fsid: str) -> None:
    """
    Set up ceph.target and ceph-$fsid.target units.
    """
    # global unit
    existed = os.path.exists(ctx.unit_dir + '/ceph.target')
    with write_new(ctx.unit_dir + '/ceph.target', perms=None) as f:
        f.write(
            '[Unit]\n'
            'Description=All Ceph clusters and services\n'
            '\n'
            '[Install]\n'
            'WantedBy=multi-user.target\n'
        )
    if not existed:
        # we disable before enable in case a different ceph.target
        # (from the traditional package) is present; while newer
        # systemd is smart enough to disable the old
        # (/lib/systemd/...) and enable the new (/etc/systemd/...),
        # some older versions of systemd error out with EEXIST.
        call_throws(ctx, ['systemctl', 'disable', 'ceph.target'])
        call_throws(ctx, ['systemctl', 'enable', 'ceph.target'])
        call_throws(ctx, ['systemctl', 'start', 'ceph.target'])

    # cluster unit
    existed = os.path.exists(ctx.unit_dir + '/ceph-%s.target' % fsid)
    with write_new(ctx.unit_dir + f'/ceph-{fsid}.target', perms=None) as f:
        f.write(
            '[Unit]\n'
            'Description=Ceph cluster {fsid}\n'
            'PartOf=ceph.target\n'
            'Before=ceph.target\n'
            '\n'
            '[Install]\n'
            'WantedBy=multi-user.target ceph.target\n'.format(fsid=fsid)
        )
    if not existed:
        call_throws(ctx, ['systemctl', 'enable', 'ceph-%s.target' % fsid])
        call_throws(ctx, ['systemctl', 'start', 'ceph-%s.target' % fsid])

    # don't overwrite file in order to allow users to manipulate it
    if os.path.exists(ctx.logrotate_dir + f'/ceph-{fsid}'):
        return

    write_cluster_logrotate_config(ctx, fsid)


def update_files(
    ctx: CephadmContext,
    ident: DaemonIdentity,
    *,
    init_container_ids: Optional[List[DaemonSubIdentity]] = None,
    sidecar_ids: Optional[List[DaemonSubIdentity]] = None,
) -> None:
    _install_base_units(ctx, ident.fsid)
    unit = _get_unit_file(ctx, ident.fsid)
    pathinfo = PathInfo(ctx.unit_dir, ident, sidecar_ids=sidecar_ids)
    with write_new(pathinfo.default_unit_file, perms=None) as f:
        f.write(unit)
    _install_extended_systemd_services(
        ctx, pathinfo, ident, bool(init_container_ids)
    )
    _update_drop_in_files(ctx, pathinfo, ident, bool(init_container_ids))


def sidecars_from_dropin(
    pathinfo: PathInfo, missing_ok: bool = False
) -> PathInfo:
    """Read the list of sidecars for a service from the service's drop in file."""
    # This is useful in the cases where the sidecars would be determined from
    # input data (deployment) but we lack the original deployment data (rm
    # daemon).
    sidecars = []
    try:
        with open(pathinfo.drop_in_file) as fh:
            lines = fh.readlines()
    except FileNotFoundError:
        if missing_ok:
            return pathinfo
        raise
    for line in lines:
        if not line.startswith('Wants='):
            continue
        for item in line[6:].strip().split():
            si, category = DaemonSubIdentity.from_service_name(item)
            if category == 'sidecar':
                sidecars.append(si)
    return PathInfo(
        pathinfo.default_unit_file.parent, pathinfo.identity, sidecars
    )
